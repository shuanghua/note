从小到大
# 冒泡排序
- 两for循环,外循环是趟数，内循环是比较次数
- 第一趟比较的结果是：得到整个数组中最大的那个数，并且把这个数放在数组的末尾
- 明确趟数和次数的规律关系
- 最好时间复杂度：O(n),最坏时间:O(n²)
- 空间复杂度:O(1)

```kotlin
fun bubbleSor() {
	val arr = intArrayOf(30, 23, 19, 56, 56, 43, 78, 69, 80, 47)
    var swapped = false
    for (i in 1 until arr.size) {//9趟，从 1 到 9，until：包含左边，不包含右边
        swapped = false
        for (j in 0 until arr.size - i) {
            if (arr[j] > arr[j + 1]) {
                val temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
                swapped = true
            }
        }
        if (!swapped) break
    }
}
```

# 选择排序
先找到数组中最小的那个数的，然后让该数和第0位置进行交换，然后再取第2小的那个数和第1位置进行交换，以此类推。一直重复，知道取出最后一个元素
- 两层for循环，外层为趟数，内层为比较两个数的大小
- 在内层循环中，每次循环的结果：得到整个数组中最小数的下标（先判断两个数的大小，如果当前数比下一个数大，则记录较小的那个数的下标，然后让这个最小数继续和下一个数比较；如果当前数小于下一个数，则当前数继续和下一个数比较），然后把该数和数组的第0位置的数进行交换
- 选择排序和冒泡排序的区别是，冒泡排序是找到最大的数放在末尾，选择排序是找到最小的数放在开头，看似一样但他们的主要区别是：冒泡是相邻两个数进行交换，而选择排序则不是相邻交换。选择排序是最小数和数组起始位置进行交换

```kotlin
fun selectSort() {
	val arr = intArrayOf(30, 23, 19, 56, 56, 43, 78, 69, 80, 47)
    var k = 0
    var min = 0
    for (i in 0 until arr.size) {
        min = i
        for (j in i + 1 until arr.size) {
            //两个数比较，得到一个最小数，循环让 这个最小数和后面的数继续比较
            // 发现更小的数则让更小的数继续和后面的数比较
            if (arr[min] > arr[j]) min = j
        }
        if (min != i) {//排除最小数本来就是在第一个位置的情况，这种情况是不需要进行数据交换的
            k = arr[i]
            arr[i] = arr[min]
            arr[min] = k
        }
    }
}
```