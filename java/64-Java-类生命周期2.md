
# 类的创建过程

加载-链接-初始化-main函数

# 加载类

虚拟机根据该类的名称检查该类是否存在二进制的表示形式，编译在编译时会生成一个 Class 对应类，这个 Class 就是我们使用反射时经常见到的，它里面包含了对类的描述（甚至可以称之该类的描述文件）
类的加载在虚拟机层面涉及到类加载器，类的加载都是有类加载器(ClassLocader 或者 ClassLoader 的子类)来加载的，前面提到的 Class 对应类，其实是由类加载器生成的，我们可以自定义类加载器来改变 Class 类的格式（比如自行决定该类的构造方式）。
自定义的类加载器一般具有两个特点：1.给定同一个类名称，始终生成返回相同的类对象。2.把一个类用放到另一个类加载器上去加载，始终返回相同的类型对象（比如泛型）。
不同的子类的 ClassLoader 可以实现不同的加载策略，类加载器可以缓存类和接口的二进制表示，基于预期用法预取它们，或者将一组相关类一起加载。
类加载器必须要遵循的一个原则是：运行时的类型不能被用Java编写时的类型代码所颠覆，甚至不能被 ClassLoader 和 SecurityManager 等原本敏感的系统类的实现所颠覆。

# 链接类

链接是将一个类或接口类型的二进制形式，绑定到 Java 虚拟机的运行时状态中，使其能够被执行的过程。
类被加载之后，需要进行链接（验证，准备，解析符号引用），然后进行初始化，这个初始化的过程是在 main函数 被调用之前执行。
 验证：验证该类时，通过使用适当的符号表来检查的已加载表示形式是否正确。验证还检查该类里面的代码是否符合 Java编程语言 和 Java虚拟机 的语义要求。如果在验证期间检测到问题，那么将引发错误。
 准备：准备工作涉及到静态存储的内存分配和 Java 虚拟机实现内部使用的任何数据结构，如方法表。
 解析：检查该类里面所引用（符号引用）的其它类是否正确。

# 初始化

执行初始化程序，在对该类进行初始化之前，还需要对该类的超类进行初始化。在 Java 中必须等到 Object 类初始化完成之后才能对该类初始化。

# 调用 Main 函数

到这一步，该类的初始化就算完成了，但在该类里面的所引用的别的类可能还在进行加载、链接和初始化。

# new 对象过程

```java
class Super {
    Super() { printThree(); }
    void printThree() { System.out.println("three"); }
}
class Test extends Super {
    int three = (int)Math.PI;  // That is, 3
    void printThree() { System.out.println(three); }

    public static void main(String[] args) {
        Test t = new Test();
        t.printThree();
    }
}

```

最终先输出的结果是0 ,然后是3。在 new Test() 的过程中，调用了Test()默认无参构造函数，Test()的无参构造函数里面会调用父类的无参构造函数，
Super()无参构造函数里面调用了 printThree(),但printThree被子类重写了,所以最终调用的是Test类里面的 printThree() ,
而此时 Test 类还没完全 new 完成,所以 int three 这变量也还没有完成实际的初始化,只是默认的初始化,也就是0.
到此 ,构造函数的代码的执行就算完成了, 再之后就是 int three = 3, 最终正式完成了 new Test 类的工作
