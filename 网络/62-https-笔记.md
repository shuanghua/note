---
toc: false
comments: false
title: 62-https 笔记
tags:
  - web
id: 62
categories:
  - web
date: 2020-5-16
---

## 服务器需要有：证书 + 私钥

> 由于 CA 机构的存在 ，我们的服务器现在不需要保存公钥了，公钥一般都在浏览器中附带了

<!-- more -->

## 密钥如何安全传输

非对称加密算法 （如 RSA），需要公钥和私钥，目前 https 中常用的是 ECDHE_RSA with P-256 和 X25519

## 数据如何安全传输

对称加密算法 （如 SHA 或者 MD5），只需要同一个密钥即可加密解密，目前 https 在传入内容的时候使用的是对称加密, 在打招呼协商用的是非对称加密, 对称加密常用的是 AES-128-GCM，AES 安全性和性能都很好， 现在大部分 CPU 大都支持 AES 指令集（可通过 CPU-Z 看到）， 除此之外根据密钥长度的不同还有 AES-192-GCM 、AES-256-GCM。

## TLS

如果 'X25519' 和 'AES-128-GCM' 是同时使用的，那么这整个加密套件归属于 TLS 1.3, 如果是 'ECDHE_RSA with P-256' 和 'AES_128_GCM ' 一起使用则是 TLS 1.2, 也就是说 TLS 是规定了这两种算法的一个标准, 不同的 TLS 版本有不同的组合标准， 近几年 TLS 已经替代了过去的 SSL， 从作用上来看 TLS 和 SSL 都是一样的作用， 两者只是标准不同。 SSL 是套接层安全协议， TLS 是传输层安全协议，他们都是为了互联网数据安全传输提供了加密标准。

## 请求流程

1. 客户端根据 url 对服务器进行请求

2. 服务器向客户端发送证书（除了证书之外还有别的，后面详细说）

3. 客户端验证证书是否是 CA 认证颁发 （不是则提示该域名所对应的证书不安全，并提示询问用户是否要继续访问，之后的访问可能会有被黑客窃听的的风险）

4. 客户端和服务器协商 TLS 版本和用于内容数据加密的一个对称加密算法等等

5. 客户端和服务器协商出了一个对称加密算法，比如是  AES-128-GCM ，然后生成一个随机值，这个随机值用于 AES-128-GCM 对称加密算法的密钥（后续称为对称密钥）。生成这个对称密钥之后，客户端用服务器给的公钥加密这个对称密钥，然后发送给服务器

6. 服务器利用私钥解密这个带对称密钥的数据，获取到这个 AES-128-GCM 对称算法的对称加密密钥,此时双方就都有一个一样的秘钥了

7. 服务用 AES-128-GCM 对应的对称密钥 加密网站数据，然后发给客户端

8. 客户端收到服务器的 AES-128-GCM 加密数据后, 利用原先的对称密钥解密即可

现在我们来记录上面第 4 步的协商过程，因为这个过程细节需要太多的文字描述，所以单独分析

## 服务器和客户端协商内容：

使用那些 TLS 版本（TLS 1.0、1.2、1.3等）
使用哪些加密算法
验证服务器的身份（主要利用证书对应的公钥和服务器的数字签名）
生成一个对称加密算法的对称密钥

## 具体协商过程

1. Client 向 Server 发送一条消息： Hello Server + 客户端支持的 TLS 版本 + 支持的加密算法 + 一串随机值

2. Server 向 Client 回应一条消息： Hello Clent + 服务器的 SSL 证书 + 服务器选定的加密算法 + 一串随机值（和客户端不一样） + 数字签名 （后面单独解释）

3. Client 验证 Server 的身份: 客户端向该证书的颁发结构验证服务器证书（ 这验证过程又是一个复杂的过程，涉及到和浏览器CA证书列表的对比，对比成功则获得对应的公钥；使用公钥数字签名， 验证通过则说明服务器是正确的目标服务器， 而不是伪造的服务器）。 该过程确认了服务器的真实性（确定是不是客户端所想访问的目标服务器）， 并且还确认客户端正在与该域名的实际拥有者进行交互。

4. 预主机密: 客户端再生成一串新随机值， 即“预主机密”。  然后使用公钥加密这个随机值并发送给服务器（只能由服务器使用私钥解密）

5. 使用私钥： 服务器用私钥解密预主机密得出里面的随机值

6. 创建通信密钥: 现在客户端和服务器都有三个随机值 （客户端第一次发的随机值，服务器第一次发的随机值 和 预主机密），客户端和服务器利用这三个随机值生成通信密钥，到此服务器和客户端就都有一个一致的通信密钥。

7. 客户端验证完成： 客户端用上面的通信密钥加密 “done" 消息发送给服务器 （对称加密传输）

8. 服务器验证完成： 服务器也用上面的通信密钥加密 “done" 消息发送给客户端 （对称加密传输）

9. 完成安全对称加密： 后续客户端和服务器都是用该通信密钥来加密数据。该通信密钥中只有预主机密值是通过非对称加密传输的，即便如此，它也是非常安全的。

## 服务器数字签名

服务器用私钥加密三个东西，这三个东西分别是：客户端随机值、服务器随机值和 DH 参数（注意不包括预主机密值，预主机密是在客户端验证数字签名之后才能生成的），之后用服务器的私钥加密这三个东西就是最终的服务器数字签名，用私钥生成的数字签名目的是为了告诉客户端：我服务器拥有你手里的公钥所对应的私钥，你客户端大可放心。

## 客户端验证数字签名

客户端使用公钥并根据签名算法解密服务器的数字签名（这里是看不到私钥的内容的，私钥内容只能服务器知道），目的验证服务器是否拥有私钥和能控制私钥的身份。客户端 DH 参数：客户端将其 DH 参数发送到服务器

## *DH 参数

DH 全称 Diffie-Hellman。Diffie-Hellman 算法使用指数计算得出相同的预主机密。服务器和客户端各自提供用于计算的参数，并且当将它们组合在一起时，它们将在每一端导致不同的计算，结果是相同的。

- 上述内容参考至: [https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/](https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/)
